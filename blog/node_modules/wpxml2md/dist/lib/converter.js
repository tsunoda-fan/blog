"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _jsdom = require("jsdom");

var _collapseWhitespace = _interopRequireDefault(require("collapse-whitespace"));

var _util = _interopRequireDefault(require("./util.js"));

var _shortcode = _interopRequireDefault(require("./shortcode.js"));

var _markdown = _interopRequireDefault(require("./markdown.js"));

var _gfm = _interopRequireDefault(require("./gfm.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Types of node.
 * @type {Object}
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
 */
const NodeTypes = {
  ELEMENT_NODE: 1,
  TEXT_NODE: 3
  /**
   * RegExp.
   * @type {Object}
   */

};
const RegExps = {
  Alphabet: /A/,
  Space: /^\s*$/i,
  Leading: /^[ \r\n\t]/,
  Trailing: /[ \r\n\t]$/
  /**
   * Check that conversion is possible.
   *
   * @param {Node} node DOM node.
   * @param {String|String[]|Function} filter Filter.
   *
   * @return {Boolean} "true" if the conversion is possible.
   */

};

const canConvert = (node, filter) => {
  if (typeof filter === 'string') {
    return filter === node.nodeName.toLowerCase();
  }

  if (Array.isArray(filter)) {
    return filter.indexOf(node.nodeName.toLowerCase()) !== -1;
  } else if (typeof filter === 'function') {
    return filter(node);
  }

  throw new TypeError('"filter" needs to be a string, array, or function');
};
/**
 * Collapse the whitespace from ELEMENT_NODE node.
 * TEXT_NODE will keep the original indentation and whitespace.
 *
 * @param {Node[]} nodes DOM nodes.
 */


const collapseWhitespace = nodes => {
  nodes.forEach(node => {
    if (node.nodeType === NodeTypes.ELEMENT_NODE) {
      (0, _collapseWhitespace.default)(node, _util.default.isBlockElement);
    }
  });
};
/**
 * Flanking the whitespaces.
 *
 * @param {Node} node DOM node.
 *
 * @return {Object} whitespaces.
 */


const flankingWhitespace = node => {
  let leading = '';
  let trailing = '';

  if (!_util.default.isBlockElement(node)) {
    const hasLeading = RegExps.Leading.test(node.innerHTML);
    const hasTrailing = RegExps.Trailing.test(node.innerHTML);

    if (hasLeading && !isFlankedByWhitespace('left', node)) {
      leading = ' ';
    }

    if (hasTrailing && !isFlankedByWhitespace('right', node)) {
      trailing = ' ';
    }
  }

  return {
    leading: leading,
    trailing: trailing
  };
};
/**
 * Flattens the tree structure of nodes.
 *
 * @param {Node} node DOM node.
 *
 * @return {Node[]} Nodes.
 */


const flattenNodes = node => {
  const inqueue = [node];
  const outqueue = [];

  while (0 < inqueue.length) {
    const elm = inqueue.shift();
    outqueue.push(elm);

    for (let i = 0, max = elm.childNodes.length; i < max; ++i) {
      const child = elm.childNodes[i];

      if (child.nodeType === NodeTypes.ELEMENT_NODE) {
        inqueue.push(child);
      }
    }
  } // Remove root


  outqueue.shift();
  return outqueue;
};
/**
 * Get a child contents text.
 *
 * @param {Node} node DOM node.
 *
 * @return {String} Text.
 */


const getContent = node => {
  let text = '';

  for (let i = 0, max = node.childNodes.length; i < max; ++i) {
    const elm = node.childNodes[i];

    if (elm.nodeType === NodeTypes.ELEMENT_NODE) {
      text += node.childNodes[i]._replacement;
    } else if (elm.nodeType === NodeTypes.TEXT_NODE) {
      text += elm.data;
    }
  }

  return text;
};
/**
 * Prepare the text for parse the jsdom.
 *
 * @param {String} text Text.
 *
 * @return {String} Prepared text.
 */


const prepareText = text => {
  const result = (0, _shortcode.default)(text); // Escape number list

  return result.replace(/(\d+)\. /g, '$1\\. ');
};
/**
 * Check a flanked by whitespace.
 *
 * @param {String} side
 * @param {Node} node Node.
 *
 * @return {Boolean} Flanked if "true".
 */


const isFlankedByWhitespace = (side, node) => {
  let sibling = null;
  let regexp = null;

  if (side === 'left') {
    sibling = node.previousSibling;
    regexp = / $/;
  } else {
    sibling = node.nextSibling;
    regexp = /^ /;
  }

  let isFlanked = false;

  if (sibling) {
    if (sibling.nodeType === NodeTypes.TEXT_NODE) {
      isFlanked = regexp.test(sibling.nodeValue);
    } else if (sibling.nodeType === NodeTypes.ELEMENT_NODE && !_util.default.isBlockElement(sibling)) {
      isFlanked = regexp.test(sibling.textContent);
    }
  }

  return isFlanked;
};
/**
 * Convert the Node to Markdown text.
 *
 * @param {Node} node DOM node.
 * @param {Converter[]} converters Converters.
 * @param {Modes} modes Modes.
 */


const process = (node, converters, modes) => {
  let content = getContent(node); // Remove blank nodes

  if (!_util.default.isVoidElement(node) && RegExps.Alphabet.test(node.nodeName) && RegExps.Space.test(content)) {
    node._replacement = '';
    return;
  }

  let replacement = '';
  converters.some(converter => {
    if (!canConvert(node, converter.filter)) {
      return false;
    }

    if (typeof converter.replacement !== 'function') {
      throw new TypeError('"replacement" needs to be a function that returns a string');
    }

    const whitespace = flankingWhitespace(node);

    if (whitespace.leading || whitespace.trailing) {
      content = _util.default.trim(content);
    }

    replacement = whitespace.leading + converter.replacement(node, content, modes) + whitespace.trailing;
    return true;
  });
  node._replacement = replacement;
};
/**
 * Convert the WordPress's post to Markdown.
 * Design and implementation was in reference to the npm to-markdown.
 *
 * @param {String} post WordPress's post text.
 * @param {Modes} modes Modes.
 *
 * @return {String} Markdown text.
 *
 * @see https://github.com/domchristie/to-markdown
 */


const Convert = (post, modes = {}) => {
  if (typeof post !== 'string') {
    throw new TypeError('"post" is not a string.');
  }

  let converters = _markdown.default.slice(0);

  if (!modes.noGFM) {
    converters = _gfm.default.concat(converters);
  }

  const body = new _jsdom.JSDOM(prepareText(post)).window.document.body;
  const nodes = flattenNodes(body);
  collapseWhitespace(nodes); // Process through nodes in reverse (so deepest child elements are first).

  for (let i = nodes.length - 1; 0 <= i; --i) {
    process(nodes[i], converters, modes);
  }

  const result = getContent(body);
  return result.replace(/^[\t\r\n]+|[\t\r\n\s]+$/g, '').replace(/\n\s+\n/g, '\n\n').replace(/\n{3,}/g, '\n\n');
};

var _default = Convert;
exports.default = _default;